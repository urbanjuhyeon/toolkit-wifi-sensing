---
number-sections: true
number-depth: 2
---

# Cleaning

The aggregated data still contains noise that distorts device counts. **Randomized MAC addresses** cause the same phone to appear as multiple different devices. **Stationary devices** like access points, fixed desktops, and IoT equipment add non-pedestrian signals.

This chapter removes both sources of error: first filtering out randomized MACs, then excluding devices that stay in place for hours. The result is a dataset of **unique mobile devices** suitable for pedestrian analysis.

```{mermaid}
%%| fig-cap: "From aggregated records to cleaned data"
%%| fig-align: center
%%{init: {'theme': 'base', 'themeVariables': { 'primaryColor': '#e8f4f8', 'primaryTextColor': '#1a1a1a', 'primaryBorderColor': '#5c9ead', 'lineColor': '#5c9ead', 'secondaryColor': '#f0f7e6', 'tertiaryColor': '#fff5e6'}}}%%
flowchart LR
    A[Aggregated<br/>CSV Files] -->|combine| B[Combined Data]

    subgraph C[Cleaning]
        direction TB
        C1[Remove Random MACs] --> C2[Remove Stationary Devices]
    end

    B --> C
    C --> D[Cleaned Data]

    style A fill:#e8f4f8,stroke:#5c9ead
    style B fill:#f0f7e6,stroke:#7cb342
    style C fill:#fff5e6,stroke:#f9a825
    style D fill:#fce4ec,stroke:#c2185b
```

## Load Data

::: {.callout-note title="Sample data"}
Download [sample_aggregated.zip](../data/tutorial/sample_aggregated.zip) if you don't have aggregated data from the previous chapter.
:::

### Install Packages

`pacman::p_load()` installs missing packages and loads them in one step.

```{r}
#| message: false
#| warning: false
if (!require(pacman)) install.packages("pacman")
pacman::p_load(data.table, lubridate, purrr)
```

- `data.table`: Fast data manipulation
- `lubridate`: Parse and manipulate timestamps
- `purrr`: Functional programming tools

### Combine Files

Multiple sensors produce separate CSV files. Combine them into a single dataset before cleaning.

```{r}
csv_files <- list.files(
  "../data/tutorial", pattern = "1second.*\\.csv$", full.names = TRUE
)

wifi_data <- csv_files |> map(fread) |> rbindlist()
```

Here are the first few rows:

```{r}
head(wifi_data, 5)
```

## Clean the Data

### Remove Random MAC Addresses

Modern smartphones **randomize their MAC addresses** for privacy, creating a new identifier each time they scan for networks. One phone can appear as dozens of different devices. We use the `source_address_randomized` flag to filter these out.

```{r}
wifi_filtered <- wifi_data[source_address_randomized != 1]
```

::: {.callout-note collapse="true"}
## How the sensor detects randomized MACs

The sensor checks the **second bit of the first byte** in the MAC address. If this bit is set to 1, the address is "locally administered"—meaning it was generated by the device rather than assigned by the manufacturer. This is the standard indicator for randomized addresses.

```
MAC: A4:C3:F0:85:7E:2D
      ^
First byte: A4 = 10100100 in binary
                      ^
            Second bit = 0 → manufacturer-assigned (not randomized)

MAC: 4E:7F:B2:91:3A:C8
      ^
First byte: 4E = 01001110 in binary
                      ^
            Second bit = 1 → locally administered (randomized)
```

The sensor flags each packet during capture, so you don't need to parse MAC addresses yourself.
:::


### Remove Stationary Devices

Stationary devices—access points, fixed desktops, IoT sensors—are detected continuously for hours at the same location. We identify them by **session duration**: how long a device stays at one sensor without leaving.

#### What is a session?

A **session** is a continuous period of detection. If a device disappears for more than 5 minutes and reappears, that counts as a new session.

```
Device A at Sensor 1:

  |----detected----|   gap > 5min   |----detected----|
       Session 1                         Session 2
      (45 minutes)                      (30 minutes)
```

A pedestrian typically has one short session (a few minutes). A fixed desktop or IoT device has sessions lasting hours.

::: {.callout-note collapse="true"}
## Why sessions instead of total detection time?

A device might appear briefly at different times throughout the day—5 minutes in the morning, 10 minutes at lunch, 3 minutes in the evening. The total is only 18 minutes, which looks like a pedestrian.

But a stationary device (like a fixed desktop or access point) stays **continuously** for hours at a time. By grouping detections into sessions, we can distinguish between:

- **Pedestrian**: multiple short visits (each under 2 hours)
- **Stationary**: at least one long continuous presence (2+ hours)

The 5-minute gap threshold reflects typical probe request intervals—if a device isn't detected for 5+ minutes, it likely left the area.
:::

#### Define thresholds

```{r}
session_gap <- 300  # 5 minutes: gap that starts a new session
duration_threshold <- 3600 * 2  # 2 hours: flag as stationary
```

- `session_gap`: If no detection for 5+ minutes, start a new session
- `duration_threshold`: If any session exceeds 2 hours, mark as stationary

#### Calculate session duration

The code below calculates the time gap between consecutive detections, groups them into sessions, and computes each session's total duration.

```{r}
wifi_filtered[, time_diff := as.numeric(
  difftime(timestamp, shift(timestamp), units = "secs")
), by = .(source_address)]

wifi_filtered[, session := cumsum(
  time_diff > session_gap | is.na(time_diff)
), by = .(source_address)]

wifi_filtered[, session_duration := sum(
  time_diff[time_diff <= session_gap], na.rm = TRUE
), by = .(sensor_name, source_address, session)]
```

#### Filter out stationary devices

Any device with at least one session exceeding 2 hours is flagged as stationary and removed from the dataset.

```{r}
stationary <- unique(
  wifi_filtered[session_duration >= duration_threshold, source_address]
)
wifi_cleaned <- wifi_filtered[!source_address %in% stationary]
```

### Save the Result

Export the cleaned data to CSV for use in subsequent analysis.

```{r}
fwrite(wifi_cleaned, "../data/tutorial/cleaned_sample.csv")
```

## Pipeline Summary

Each cleaning step reduces noise. In this sample, random MAC filtering reduces 243 apparent devices to 178—a **27% reduction**. These removed entries are duplicates from phones using different randomized identifiers. The stationary filter has no effect here because the sample spans only a few minutes; with longer deployments (12+ hours), this filter removes significantly more devices.

```{r}
summary_table <- data.table(
  Step = c("Initial", "After Random MAC Removal", "After Stationary Removal"),
  Records = c(nrow(wifi_data), nrow(wifi_filtered), nrow(wifi_cleaned)),
  Unique_Devices = c(
    uniqueN(wifi_data$source_address),
    uniqueN(wifi_filtered$source_address),
    uniqueN(wifi_cleaned$source_address)
  )
)

print(summary_table)
```

## Automate the Pipeline

For larger deployments spanning days or weeks, you'll have **many CSV files** to process. The `clean_wifi_data()` function below wraps all cleaning steps into a single reusable call.

```{r}
clean_wifi_data <- function(csv_files, session_gap = 300, duration_threshold = 7200) {
  # Combine all files
  wifi_data <- rbindlist(lapply(csv_files, fread))

  # Remove random MACs
  wifi_filtered <- wifi_data[source_address_randomized != 1]

  # Calculate sessions
  wifi_filtered[, time_diff := as.numeric(
    difftime(timestamp, shift(timestamp), units = "secs")
  ), by = .(source_address)]

  wifi_filtered[, session := cumsum(
    time_diff > session_gap | is.na(time_diff)
  ), by = .(source_address)]

  wifi_filtered[, session_duration := sum(
    time_diff[time_diff <= session_gap], na.rm = TRUE
  ), by = .(sensor_name, source_address, session)]

  # Remove stationary devices
  stationary <- unique(
    wifi_filtered[session_duration >= duration_threshold, source_address]
  )
  wifi_cleaned <- wifi_filtered[!source_address %in% stationary]

  # Drop helper columns
  wifi_cleaned[, c("time_diff", "session", "session_duration") := NULL]

  return(wifi_cleaned)
}
```

Run on all aggregated files:

```{r}
csv_files <- list.files("../data/tutorial", pattern = "1second.*\\.csv$", full.names = TRUE)
cleaned_data <- clean_wifi_data(csv_files)

head(cleaned_data)
```
